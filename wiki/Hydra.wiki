#summary The J1772 "Hydra" - Charge 2 EVs from one EVSE.

= The Hydra =

We have 6 L2 J1772 chargers and a CHAdeMO at work. For various reasons, my colleagues are more politically attuned to EV ownership than the general population, even here in the SF Bay area. So those chargers are oversubscribed. What makes it worse is that most of those cars are Leafs, which only charge from those L2 chargers at 15A. Since the chargers are 30A, half the potential is being wasted. Why they don't just use the CHAdeMO is beyond me.

It would be easy to make a box with a square wave generator to dummy up a pilot to feed two cars from a J1772 inlet, but that would neither be spec compliant, nor safe. No, the correct thing to do is to intelligently allocate the incoming power to the two cars as needed.

And thus, the Hydra was born.

= Details =

The Hydra owes much of its existence to OpenEVSE. Some of its circuitry was cribbed from the OpenEVSE Plus. The Hydra has the same 16 MHz ATMega controller as the OpenEVSE and Arduino Uno. Connected to that are the following subsystems:

  * A comparator to convert the incoming pilot signal into a TTL compatible square wave so that the controller can determine the duty cycle, and thus, the ampacity of the host EVSE.
  * A comparator to watch for transitions on the incoming proximity pin. The controller will gracefully shut down both cars if the proximity resistance rises above 300 ohms (or so).
  * Two pilot signal generators. OP Amps are used to convert digital outputs from the controller into + or - 12 volt outputs. The PWM timer systems of the controller are used to generate the varying duty cycles.
  * Resistor networks feed the outgoing pilots back into the controller on two analog pins so that state changes and diode failures on each car can be detected.
  * Each car has a current transformer on one of its hot leads so that the car's current draw can be monitored. If a car exceeds its allocated current, it is shut down.
  * The Hydra has an RGB LCD display to show status information.

The shared mode in the Hydra has the following rules:

  * If no car is charging, both cars get 100% of the incoming pilot.
  * If one car is charging, it gets 100% and the other car gets 50%.
  * If both cars are charging, both cars get 50%.
  * If both cars are charging and one stops, the other pilot is immediately raised to 100%. The car that stopped continues to get 50% in accordance with the above rules.
  * If only one car is charging, and the other enters state C, it will be given a delay. During that delay, the other car's pilot is reduced to 50% and it will be given a brief interval to respond and reduce its draw. After the delay, the second car's power will be turned on.
  * If any car exceeds its current allowance for for too long, it is errored out.
  * If any car fails a diode check at any time, it is errored out.
  * If any car enters an invalid state (7.5 volts, for instance - between B and C), it is errored out.
  * If the incoming pilot drops below the 12A minimum (because that's the smallest that can legally be split in half) or stops being a valid pilot, both cars are errored out.
  * If the proximity is pushed on the inlet, both cars are errored out.
  * If a car is errored out, its plug must return to state A to clear the error (so pull the plug out and reinsert it).

The sequential mode operates by giving a full-power pilot to only one car at a time. The first car to be connected after establishing sequential mode will be given the pilot. It will keep the pilot until it transitions from mode C or D back to B. When it does so, if another car is connected (and in state B), then it will be given the pilot, and the pilot will be taken away from the first car. Both cars will "pass the baton" back and forth. A car entering state C without its pilot being enabled will result in a "T" (illegal transition) error.

The Hydra does not attempt to detect L1 vs L2 - it only cares about amps. It also doesn't attempt to detect ground faults - the source EVSE is assumed to have its own GFCI. Also, my prototype does not include fuses or breakers - again, the source EVSE is assumed to have over-current protection.

The board has the following interface points:

  * 2 two pin terminals for the coils for two power relays for car A & B
  * 2 two pin terminals for the current transformers for car A & B
  * 2 three pin terminals - one for each car that has the outgoing pilot and proximity signals, plus a ground connection
  * 1 three pin terminal that comes from the inlet, with ground, pilot and proximity
  * 1 two pin terminal that brings 12 VDC from an external power supply
  * 1 two pin terminal that connects to an external power switch. This switch switches the inlet pilot resistance from state B to state C when closed. Optionally, you can simply jumper the terminal if you would rather.
  * 1 4 pin I2C header for the LCD
  * 1 2x3 pin ISP socket for programming
  * 1 6 pin FTDI header for serial I/O (for debugging, programming or future expansion)

There are 3 things on the board that require some attention:
  * R8 is a 2.7k resistor that runs between proximity and ground. Some (most? all?) J1772 inlets come with a 2.7k resistor installed between proximity and ground. If yours does, then do not install R8.
  * R14 and R17 are burden resistors for the CT coils. These need to be chosen based on the CT you're going to use and the maximum outlet current rating for your Hydra. For my prototype, the CTs I've selected have a Te of 1018 and the design current for the Hydra will be 30A. For that configuration, a 56 ohm resistor is appropriate. You'll also find a #define in the source code for the Hydra that you will need to adjust in concert with this. Customizing the burden resistor allows you to maximize the accuracy of the ammeter readings for each car.
  * If you do not plan on using serial programming and a bootloader, you may wish to leave out C11. Placing C11 will allow DTR on the serial port to reset the controller as a prelude to serial programming. If you plan on using serial programming exclusively, then you can leave out the ISP connector.

The software is hosted on GitHub at https://github.com/nsayer/hydra

You have two choices on programming the Hydra. First, you can program using an AVR ISP programmer connected to the 6 pin ISP socket. This is exactly the same way OpenEVSE is programmed.

Alternatively, if you do not have an AVR ISP programmer, but do have an FTDI style serial cable, you can use an ATMega chip with a standard Arduino Uno bootloader installed. Connect the cable up to the FTDI port on the board, select the Arduino Uno in the 'boards' menu, select the correct serial port in the serial menu and upload the sketch as usual.

Of course, your ATMega chip must already have a bootloader and be fused as appropriate for an Uno. If you buy a "raw" ATMega chip, you'll still need to fuse it and load a bootloader with an ISP programmer.

= Safety =

There are no hazardous voltages on the Hydra controller board itself under normal circumstances. However, the Hydra is designed to work with 240 volt AC power, which can easily injure or kill.

I strongly recommend that you never connect a J1772 plug into the inlet when the chassis is open. You cannot take for granted that the host EVSE will not apply power to the hot lines at any time - be it a malfunction or otherwise.

You can program the controller without AC power applied (that is, without anything plugged into the inlet. Both the FTDI and ISP connectors pass programming power to the +5 supply rail from the programmer. If you intend to connect anything to the FTDI port for use while the system is running, you should not operate the Hydra with the chassis open in order to do so.

= Wiring =

The two car relays are DPST relays with 12vdc coils rated for whatever your outlet current is. They're the same kind as used for OpenEVSE.

In some (most?) cases, the J1772 inlet you get will be higher rated than your plugs and cables. The software is capable of limiting the inlet current separately, but in order to take advantage of this, you must insure that your relays are wired in a "star" pattern rather than daisy-chained. In a daisy-chain, the full current of the entire system will flow through the first component's cables, limiting the design current to that capacity. If you connect each relay's supply leads together to the inlet supply at the same point, then the inlet current is allowed to be higher.

For each relay, designate a "line" side and a "load" side. On the line side, run a wire (for 30A, use 10 gauge) from each terminal of the relay to one of the two inlet hot cables. I used (large) wire nuts to connect the three wires for each phase together.

You also need to get "line" power into the power supply. It can use 22 gauge wire. You can add those wires into the wire nut forest.

On the load side of each relay, connect up the hot wires of one of the J1772 cables. Run one of the hot lines through a CT coil before connecting it to the relay. Unlike OpenEVSE, you run only one of the lines through the coil, not both. It doesn't matter which one you pick.

Be sure that you pair up the relay coil wires with the CT coil wires. It doesn't matter which pair is A or B (other than car "A" being on the left side of the LCD display), but be sure that the lines for each relay coil and CT correspond to the correct pilot and proximity lines.! You don't want to measure the wrong car's current draw or even worse - power up the wrong plug. 

Don't forget to connect all of the grounds to a ground bus:

  * The inlet ground
  * Each plug/cable ground
  * The inlet ground connection from the board
  * the output pilot ground connections from the board
  * (if applicable) any ground from the power supply

If desired, connect a SPST switch up to the POWER_SW terminals on the board. If you don't want to do this, then you must place a jumper across them instead. 22 gauge wire is sufficient in either case. The power switch doesn't actually carry any appreciable current on it.

Lastly, connect the LCD up via the I2C cable. Unlike OpenEVSE, there is no support for the buttons or the RTC (if applicable).

= How to =

You will need:

  # A circuit board from OSHPark. Currently, the 1.4 version board is recommended.
  # An OpenEVSE RGB LCD backpack from the OpenEVSE store
  # The contents of the PCB BOM from DigiKey
  # The contents of the chassis BOM from DigiKey
  # A J1772 inlet
  # 2 J1772 cable/plug assemblies
  # A case and 2 cable glands. I recommend a Polycase WC-40, a WX-42 internal mounting panel and 2 CG-16 cable glands.
  # Either an FTDI cable or an AVR ISP programmer of some sort. If you go with an FTDI cable, then your controller chip must come pre-programmed with an Arduino bootloader.

The circuit board BOM from DigiKey is around $40 + tax and shipping. The chassis BOM (2 relays, 2 CTs, and a 12vdc power supply) is around $85 + tax and shipping. A J1772 inlet is $120 from Modular EV Power and J1772 cables are $150 each from Leviton. A box and two cable glands are around $50 from Polycase. So just in parts alone, a Hydra costs close to $700.

= Burden resistor calculations =

R14 and R17 must be matched to both your CT and your maximum expected outlet current. The reference design has a 30A maximum outlet current and the CT has a Te rating of 1018.

You must select the largest Rb value you can such that the maximum peak-to-peak voltage does not exceed 5 volts. Take the maximum current and divide it by Te. The maximum current is an RMS value, however, so to convert it to peak-to-peak, multiply by 2 `*` sqrt(2). Divide 5 by the result and select the next smaller standard resistor value. That's the value to use for R14 and R17. Be sure to buy precision resistors. The BOM specs 1%.

If you change the values of R14 or R17 and/or the CT, then you must change the CURRENT_SCALE_FACTOR constant in the code to match.

Divide Rb by Te to get volts per amp. Divide that value by (5/1024) to get units per amp. Divide 1000 by units per amp to get milliamps per unit, which is the value of CURRENT_SCALE_FACTOR.

= Chassis assembly instructions =

You can, of course, build your Hydra however you like, but the formula that works best for me goes something like this:

On the WC-40, pick one of the short sides to be the "top." In the middle of this side, drill a 5/8" hole for the mode button. On the opposite short side, drill a 1 5/8" hole 1 3/8" down from the upper edge of the box (not counting the lid). Insert and center the inlet, then mark the four 1/8" holes in the corners. Once drilled, use 1/2" 6-32 bolts, nuts and lock washers to install the inlet. On the two long sides, drill a 1 1/8" hole centered on the lower "half" of the side (that is, between the short side with the inlet hole and the "rib" that runs up from the back at the center of the long side). Those two holes will be for the CG-16 cable glands. Use a Dremel and knock off the two panel supports nearest the button hole, but NOT the ones with the threaded inserts. Those two panel supports will eventually collide with the standoffs for the LCD panel we are going to install.

On the WX-42 panel, use the LCD and main board as templates to mark the mounting holes. You want the LCD near, but not at, the top of the panel, and the main board 1/4" below it. A half inch below the bottom of the board, center the two relays, and a half inch below the bottom of the relays, the ground bar. Once you've marked the location for the main board, mark the two holes for the power supply module centered in the middle - the power supply will be mounted under the main board.

Use 4 2" 4-40 M-F nylon hex standoffs for the display and 4 1-3/8" metal 4-40 M-F hex standoffs for the main board. Use 2 1-3/4" 4-40 bolts, nuts and lock washers to secure the power supply. Be sure to install the wires for the power supply *before* installing the main board - the power supply will be inaccessible later. Use a 4-40 nut and lock washer to secure each standoff, then use a 1/4" 4-40 bolt to attach the LCD and main board. Don't forget the spacers on each corner between the LCD and its backpack board. Before attaching the LCD, you'll probably want to attach the i2c and button cables.

Use 1/2" 6-32 bolts, nuts and lock washers to secure the relays. Be sure to orient the relays so that the coil tabs are nearest the logic board.

Cut four short (around 4 inches or so) #10 wires - two red, two black. Attach a QD female connector to one end of each. Connect a red and a black to each relay on the "line" side. Gather each red wire, the red wire from the inlet and the red wire coming from the power supply and twist on a large wire nut. Do the same for the blacks. Run the proximity and pilot wire from the inlet to the logic board, Run a small wire from the inlet ground connector on the board to the ground bus. Run the inlet ground wire to the ground bus as well.

Next, install each cable/plug set. Attach QD female connectors on the red and black lines. Pass one of the hot lines of each plug through the respective current transformer, and then connect each hot line to one of the two relays on the "load" side. Connect the ground cable to the ground bus. Connect the pilot line and the proximity line (if available) to the respective connectors on the main board.

Be sure that each car plug's relay coil wires, current transformer wires and pilot and proximity wires all, as a group, go to the same "car" side of the logic board. You do not want to turn the wrong car's power on!

Carefully tuck all of the wires down out of the way and attach the lid. Test and enjoy!

= Firmware details =

The firmware depends on the LiquidTWI2 library to drive the LCD, and the PWM library to support altering the PWM frequency on the digital pins so that they can be used to drive the pilot outputs.

= Theory of Operation =

== Host EVSE signals ==

The incoming pilot wire from the host EVSE goes through D3 (as required by the spec) and R5. Those two components are sufficient to transition the host EVSE to state B, but unfortunately no power is supplied by the EVSE until and unless a transition to state C occurs. R6 and the power switch accomplish this. In most cases, merely jumping the power switch permanently is acceptable. If your EVSE does not tolerate jumping directly to state C, then you must manually engage state C with a switch.

The pilot, fresh from D3, also arrives at the non-inverting input to IC1A. The inverting input is set with a voltage divider to 1 volt. Thus, when the incoming pilot is more than 1 volt, the output of the comparator will be high (thanks to pull-up resistor R30). The pilot must be compared to a non-zero voltage because D3 prevents us from seeing the negative portion of the pilot signal (which we wouldn't want to present to the comparator anyway).

The proximity line is scaled (as per the spec) with R7 and R8 (which is either on the board or installed on the inlet itself). The conditioned proximity signal is fed to the inverting input. The voltage divider on the non-inverting input is set for 2 volts. The specification says that when the handle is fully connected it should be 1.5 volts and 3 volts when the button is pressed. The comparator output (pulled up by R31) will be low whenever the proximity pin is less than 2 volts. This means that the proximity circuit is in the 'ready' state.

== Outgoing EV signal handling ==

Pilot generation requires a bipolar 12 vdc power supply. This is created with DC1. R18 and R19 provide a minimal load for the converter, as the pilot generation circuitry alone is not a large enough load. The two voltages are fed into IC3.

The two non-inverting inputs of IC3 are fed with a single voltage divider for 2.5 volts (really it just needs to distinguish between high and low logic levels from the controller). The output of each is fed through a 1K resistor (per spec) and sent to the car.

The output pilot signal is also fed into a scaling and voltage divider network to convert the -12 to +12 volt signal into an approximate 0 to 5 volt range. This is in turn fed into one of the analog read pins on the controller. This allows the firmware to detect transition changes on the pilot pins.

When the host EVSE inlet has a proximity transition, that must be passed along to the vehicles, as the specification calls only calls for a rapid response to proximity transitions, not pilot changes. It's desirable to insure that all load is removed before the host EVSE plug is pulled.

To accomplish this, the controller has a single outlet proximity signal. R34 and Q3 form an open collector for this signal. R35's value is such that the proximity value seen by the EV is just under 4 volts, which should be sufficient for the vehicle to see a transition. D8 and D9 are used to prevent the proximity signal from one car from affecting the other car under normal conditions.

== Ammeters ==

Each current transformer acts as an AC current source. R14 and R17 are burden resistors that convert the current into a voltage, which the ADCs can interpret. One of the legs of the CT is anchored to 2.5 volts (with the voltage dividers R12 & R13, and R15 & R16). The burden resistors are intended to provide a peak-to-peak maximum voltage of 5 volts. R33 and D4 & D5 (and R32, D6 & D7) form a clamp to protect the controller from excessive excursions.

== Relays ==

The relay outputs are fed from fairly standard open collector circuits (R2 & Q1; R1 & Q2). D1 and D2 protect the transistors from coil collapse voltages.

== Controller ==

The controller is fused for external crystal timing, and a 16 MHz crystal is chosen to be compatible with the Arduino IDE. The ISP programming pins (including /RESET) are connected to an ISP header. Those pins are not shared with other functions. The i2c bus is brought out to a 4 pin header for an LCD and the async serial pins are brought out to an FTDI connector. DTR on the FTDI connector is connected to /RESET through a capacitor so that DTR transitions can reset the CPU. If you load an Arduino style bootloader, then programming can be done with an FTDI cable instead of an ISP cable. Alternatively, since 5 volts is supplied to the FTDI cable, it can power external serially connected devices.

The inlet's AC power is connected to an off-board AC-to-DC converter module which outputs 12 volts. DC-DC converter DC2 converts this into 5 volts for the controller and the rest of the logic system.

= Images =

[http://www.kfu.com/~nsayer/evse/hydra-14.jpg]
The 1.4 board fully assembled, with connections diagrammed.

Clockwise from upper right:
  * Relay for car A
  * Relay for car B
  * J1772 for car A - top to bottom: proximity, pilot, ground
  * J1772 for car B - right to left: proximity, pilot, ground
  * (just above the car B connector) FTDI serial connector
  * Current transformer for car A
  * Current transformer for car B
  * power switch
  * J1772 inlet - top to bottom: proximity, pilot, ground
  * 12 VDC power input
  * i2c bus

And in the middle of the board, the ISP.

= Board version history =

  * 0.5 - initial version
  * 0.9 - Attempted correction for DC-DC pad spacing (still wrong), added resistor before zener clamp in ammeters.
  * 1.0 - Corrected DC-DC pad spacing, added FTDI connector (but with RX and TX backwards).
  * 1.3 - Corrected FTDI connector, reverted to 6 pin DC-DC pads for CUI modules. Switch from 2N2222 transistors to 2N4401 for relay drivers. Added outgoing proximity circuitry. This version contained a major error causing the +5 v supply to be shorted to ground.
  * 1.4 - Corrected short circuit in v1.3.
  * 1.5 - Added bypass cap to CT anchor - improves low current ammeter accuracy.

Currently, 1.4 is the recommended version (1.5 has not yet been validated).

= Links =

  * [https://squareup.com/market/nick-sayer My online store for boards and kits]
  * [http://github.com/nsayer/hydra Software repository for the Hydra]
  * [http://code.google.com/p/arduino-pwm-frequency-library PWM library]
  * [http://github.com/lincomatic/LiquidTWI2 LiquidTWI2 library]
  * [http://oshpark.com/profiles/nsayer OSHPark store for Hydra boards]
  * HydraCourtesyNote - a page to share when using the Hydra in public