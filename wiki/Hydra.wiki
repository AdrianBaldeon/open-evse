#summary The J1772 "Hydra" - Charge 2 EVs from one EVSE.

= The Hydra =

We have 6 L2 J1772 chargers and a CHAdeMO at work. For various reasons, my colleagues are more politically attuned to EV ownership than the general population, even here in the SF Bay area. So those chargers are oversubscribed. What makes it worse is that most of those cars are Leafs, which only charge from those L2 chargers at 15A. Since the chargers are 30A, half the potential is being wasted. Why they don't just use the CHAdeMO is beyond me.

It would be easy to make a box with a square wave generator to dummy up a pilot to feed two cars from a J1772 inlet, but that would neither be spec compliant, nor safe. No, the correct thing to do is to intelligently allocate the incoming power to the two cars as needed.

And thus, the Hydra was born.

= Details =

The Hydra owes much of its existence to OpenEVSE. Some of its circuitry was cribbed from the OpenEVSE Plus. The Hydra has the same 16 MHz ATMega controller as the OpenEVSE and Arduino Uno. Connected to that are the following subsystems:

  * A comparator to convert the incoming pilot signal into a TTL compatible square wave so that the controller can determine the duty cycle, and thus, the ampacity of the host EVSE.
  * A comparator to watch for transitions on the incoming proximity pin. The controller will gracefully shut down both cars if the proximity resistance rises above 300 ohms (or so).
  * Two pilot signal generators. OP Amps are used to convert digital outputs from the controller into + or - 12 volt outputs. The PWM timer systems of the controller are used to generate the varying duty cycles.
  * Resistor networks feed the outgoing pilots back into the controller on two analog pins so that state changes and diode failures on each car can be detected.
  * Each car has a current transformer on one of its hot leads so that the car's current draw can be monitored. If a car exceeds its allocated current, it is shut down.
  * The Hydra has an RGB LCD display to show status information.

The software in the Hydra has the following rules:

  * If no car is charging, both cars get 100% of the incoming pilot.
  * If one car is charging, it gets 100% and the other car gets 50%.
  * If both cars are charging, both cars get 50%.
  * If both cars are charging and one stops, the other pilot is immediately raised to 100%. The car that stopped continues to get 50% in accordance with the above rules.
  * If only one car is charging, and the other enters state C, it will be given a delay. During that delay, the other car's pilot is reduced to 50% and it will be given a brief interval to respond and reduce its draw. After the delay, the second car's power will be turned on.
  * If any car exceeds its current allowance for for too long, it is errored out.
  * If any car fails a diode check at any time, it is errored out.
  * If any car enters an invalid state (7.5 volts, for instance - between B and C), it is errored out.
  * If the incoming pilot drops below the 12A minimum (because that's the smallest that can legally be split in half) or stops being a valid pilot, both cars are errored out.
  * If the proximity is pushed on the inlet, both cars are errored out.
  * If a car is errored out, its plug must return to state A to clear the error (so pull the plug out and reinsert it).

The Hydra does not attempt to detect L1 vs L2 - it only cares about amps. It also doesn't attempt to detect ground faults - the source EVSE is assumed to have its own GFCI. Also, my prototype does not include fuses or breakers - again, the source EVSE is assumed to have over-current protection.

The board has the following interface points:

  * 2 two pin terminals for the coils for two power relays for car A & B
  * 2 two pin terminals for the current transformers for car A & B
  * 1 three pin terminal that has the two outgoing pilot signals, plus a ground connection
  * 1 three pin terminal that comes from the inlet, with ground, pilot and proximity
  * 1 two pin terminal that brings 12 VDC from an external power supply
  * 1 two pin terminal that connects to an external power switch. This switch switches the inlet pilot resistance from state B to state C when closed. Optionally, you can simply jumper the terminal if you would rather.
  * 1 4 pin I2C header for the LCD
  * 1 2x3 pin ISP socket for programming
  * 1 6 pin FTDI header for serial I/O (for debugging, programming or future expansion)

There are 3 things on the board that require some attention:
  * R8 is a 2.7k resistor that runs between proximity and ground. Some (most? all?) J1772 inlets come with a 2.7k resistor installed between proximity and ground. If yours does, then do not install R8.
  * R14 and R17 are burden resistors for the CT coils. These need to be chosen based on the CT you're going to use and the maximum outlet current rating for your Hydra. For my prototype, the CTs I've selected have a Te of 1018 and the design current for the Hydra will be 30A. For that configuration, a 56 ohm resistor is appropriate. You'll also find a #define in the source code for the Hydra that you will need to adjust in concert with this. Customizing the burden resistor allows you to maximize the accuracy of the ammeter readings for each car.
  * If you do not plan on using serial programming and a bootloader, you may wish to leave out C11. Placing C11 will allow DTR on the serial port to reset the controller as a prelude to serial programming. If you plan on using serial programming exclusively, then you can leave out the ISP connector.

The software is hosted on GitHub at https://github.com/nsayer/hydra

You have two choices on programming the Hydra. First, you can program using an AVR ISP programmer connected to the 6 pin ISP socket. This is exactly the same way OpenEVSE is programmed.

Alternatively, if you do not have an AVR ISP programmer, but do have an FTDI style serial cable, you can use an ATMega chip with a standard Arduino Uno bootloader installed. Connect the cable up to the FTDI port on the board, select the Arduino Uno in the 'boards' menu, select the correct serial port in the serial menu and upload the sketch as usual.

Of course, your ATMega chip must already have a bootloader and be fused as appropriate for an Uno. If you buy a "raw" ATMega chip, you'll still need to fuse it and load a bootloader with an ISP programmer.

= Safety =

There are no hazardous voltages on the Hydra controller board itself under normal circumstances. However, the Hydra is designed to work with 240 volt AC power, which can easily injure or kill.

I strongly recommend that you never connect a J1772 plug into the inlet when the chassis is open. You cannot take for granted that the host EVSE will not apply power to the hot lines at any time - be it a malfunction or otherwise.

You can program the controller without AC power applied (that is, without anything plugged into the inlet. Both the FTDI and ISP connectors pass programming power to the +5 supply rail from the programmer. If you intend to connect anything to the FTDI port for use while the system is running, you should not operate the Hydra with the chassis open in order to do so.

= Wiring =

The two car relays are DPST relays with 12vdc coils rated for whatever your outlet current is. They're the same kind as used for OpenEVSE.

In some (most?) cases, the J1772 inlet you get will be higher rated than your plugs and cables. The software is capable of limiting the inlet current separately, but in order to take advantage of this, you must insure that your relays are wired in a "star" pattern rather than daisy-chained. In a daisy-chain, the full current of the entire system will flow through the first component's cables, limiting the design current to that capacity. If you connect each relay's supply leads together to the inlet supply at the same point, then the inlet current is allowed to be higher.

For each relay, designate a "line" side and a "load" side. On the line side, run a wire (for 30A, use 10 gauge) from each terminal of the relay to one of the two inlet hot cables. I used (large) wire nuts to connect the three wires for each phase together.

You also need to get "line" power into the power supply. It can use 22 gauge wire. You can either add those wires into the wire nut forest or you can piggyback one of the quick connects on one of the relays.

On the load side of each relay, connect up the hot wires of one of the J1772 cables. Run one of the hot lines through a CT coil before connecting it to the relay. Unlike OpenEVSE, you run only one of the lines through the coil, not both. It doesn't matter which one you pick.

Be sure that you pair up the relay coil wires with the CT coil wires. It doesn't matter which pair is A or B (other than car "A" being on the left side of the LCD display), but be sure that the lines for each relay coil match the corresponding CT! You don't want to measure the wrong car's current draw. Be sure also to connect the pilot leads up to the correct pilot outputs (A or B). Again, don't want to mix up the two cars.

The proximity wires, if present, from the car plug/cable sets is not used.

Don't forget to connect all of the grounds to a ground bus:

  * The inlet ground
  * Each plug/cable ground
  * The inlet ground connection from the board
  * the output pilot ground connection from the board
  * (if applicable) any ground from the power supply

If desired, connect a SPST switch up to the POWER_SW terminals on the board. If you don't want to do this, then you must place a jumper across them instead. 22 gauge wire is sufficient in either case. The power switch doesn't actually carry any appreciable current on it.

Lastly, connect the LCD up via the I2C cable. Unlike OpenEVSE, there is no support for the buttons.

= Real world reports =
== First prototype report ==

I got the first boards back from OSH Park over the last weekend (8/3/13) and assembled it. In the process, I made some discoveries that I will need to fix before I can recommend the boards to anyone else:

1. The DC-DC converters are 7 pin SIP devices and the board layout part I used is a 6 pin one. The pinouts are correct, but you must bend the pins awkwardly to get them to go and it's not mechanically very sound.

2. Most of the capacitor layouts are too narrow. You must awkwardly bend the pins to get them to fit.

3. The resistor pads are the correct distance apart, and the layout grid is fine, but the solder pads are far too small.

Apart from that, the prototype proved the basic design on the bench and the software has progressed from alpha to beta. When I have made the proposed changes, I will release the Eagle board and schematic files as hardware version 1.0.

Meanwhile, the prototype design has been used at our office for a week now and has worked flawlessly (after a firmware update or three).

I have made the changes to the Eagle files and added them to the downloads. The hardware is officially v0.9. I am going to build a 0.9 board for the prototype and to validate the 0.9 design. If it has no errors, I'll re-label it as 1.0.

== Second prototype report ==

The second prototype (hardware v0.9) still didn't have the DC-DC converter spacing perfect, so there have been a couple of changes to the v1.0 board. But I am confident now that the 1.0 design is ready for release. You can find a zip file in the project downloads with the 1.0 .BRD and .SCH files for Eagle, along with a PDF schematic and the two DigiKey BOM files for ordering the parts.

== Version 1.4 ==

(note: version 1.3 had a layout error that shorted out the 5 volt power supply to ground. Fortunately, I don't think anyone but me actually has any of those).

Since 1.0, ST Micro has deprecated the 2N2222 transistor. I've decided to replace it with a 2N4401, which despite being in a plastic case still has enough collector current to drive the relays with a large margin.

Also, the Murata DC-DC converters went out-of-stock on DigiKey, so I've gone with CUI modules, which ironically enough require the 6 pin SIP layout of the original prototype.

Version 1.4 is also the version that introduces the outgoing proximity circuitry.

= How to =

You will need:

  # A circuit board from OSHPark. Currently, the 1.4 version board is recommended.
  # An OpenEVSE RGB LCD backpack from the OpenEVSE store
  # The contents of the PCB BOM from DigiKey
  # The contents of the chassis BOM from DigiKey
  # A J1772 inlet
  # 2 J1772 cable/plug assemblies
  # A case and 2 cable glands. I recommend a Polycase WC-40, a WX-42 internal mounting panel and 2 CG-16 cable glands.
  # If you don't have one, you'll need an AVR ISP programmer of some sort.

The circuit board BOM from DigiKey is around $40 + tax and shipping. The chassis BOM (2 relays, 2 CTs, a pair of M-M-F quick connect adapters and a 12vdc power supply) is around $85 + tax and shipping. A J1772 inlet is $120 from Modular EV Power and J1772 cables are $150 each from Leviton. A box and two cable glands are around $50 from Polycase. So just in parts alone, a Hydra costs close to $700.

Note that the circuit board BOM includes R8. Do not populate R8 if your inlet has a 2.7K resistor installed between proximity and ground. Also, note that R14 and R17 have been chosen with the presumption that your outgoing current limit is 30A and you're using the CTs on the chassis BOM.

= Burden resistor calculations =

R14 and R17 must be matched to both your CT and your maximum expected outlet current. The reference design has a 30A maximum outlet current and the CT has a Te rating of 1018.

You must select the largest Rb value you can such that the maximum peak-to-peak voltage does not exceed 5 volts. Take the maximum current and divide it by Te. The maximum current is an RMS value, however, so to convert it to peak-to-peak, multiply by 2 `*` sqrt(2). Divide 5 by the result and select the next smaller standard resistor value. That's the value to use for R14 and R17. Be sure to buy precision resistors. The BOM specs 1%.

If you change the values of R14 or R17 and/or the CT, then you must change the CURRENT_SCALE_FACTOR constant in the code to match.

Divide Rb by Te to get volts per amp. Divide that value by (5/1024) to get units per amp. Divide 1000 by units per amp to get milliamps per unit, which is the value of CURRENT_SCALE_FACTOR.

= Firmware details =

The firmware depends on the LiquidTWI2 library to drive the LCD, and the PWM library to support altering the PWM frequency on the digital pins so that they can be used to drive the pilot outputs.

= Theory of Operation =

== Host EVSE signals ==

The incoming pilot wire from the host EVSE goes through D3 (as required by the spec) and R5. Those two components are sufficient to transition the host EVSE to state B, but unfortunately no power is supplied by the EVSE until and unless a transition to state C occurs. R6 and the power switch accomplish this. In most cases, merely jumping the power switch permanently is acceptable. If your EVSE does not tolerate jumping directly to state C, then you must manually engage state C with a switch.

The pilot, fresh from D3, also arrives at the non-inverting input to IC1A. The inverting input is set with a voltage divider to 1 volt. Thus, when the incoming pilot is more than 1 volt, the output of the comparator will be high (thanks to pull-up resistor R30). The pilot must be compared to a non-zero voltage because D3 prevents us from seeing the negative portion of the pilot signal (which we wouldn't want to present to the comparator anyway).

The proximity line is scaled (as per the spec) with R7 and R8 (which is either on the board or installed on the inlet itself). The conditioned proximity signal is fed to the inverting input. The voltage divider on the non-inverting input is set for 2 volts. The specification says that when the handle is fully connected it should be 1.5 volts and 3 volts when the button is pressed. The comparator output (pulled up by R31) will be low whenever the proximity pin is less than 2 volts. This means that the proximity circuit is in the 'ready' state.

== Outgoing EV signal handling ==

Pilot generation requires a bipolar 12 vdc power supply. This is created with DC1. R18 and R19 provide a minimal load for the converter, as the pilot generation circuitry alone is not a large enough load. The two voltages are fed into IC3.

The two non-inverting inputs of IC3 are fed with a single voltage divider for 2.5 volts (really it just needs to distinguish between high and low logic levels from the controller). The output of each is fed through a 1K resistor (per spec) and sent to the car.

The output pilot signal is also fed into a scaling and voltage divider network to convert the -12 to +12 volt signal into an approximate 0 to 5 volt range. This is in turn fed into one of the analog read pins on the controller. This allows the firmware to detect transition changes on the pilot pins.

When the host EVSE inlet has a proximity transition, that must be passed along to the vehicles, as the specification calls only calls for a rapid response to proximity transitions, not pilot changes. It's desirable to insure that all load is removed before the host EVSE plug is pulled.

To accomplish this, the controller has a single outlet proximity signal. R34 and Q3 form an open collector for this signal. R35's value is such that the proximity value seen by the EV is just under 4 volts, which should be sufficient for the vehicle to see a transition. D8 and D9 are used to prevent the proximity signal from one car from affecting the other car under normal conditions.

== Ammeters ==

Each current transformer acts as an AC current source. R14 and R17 are burden resistors that convert the current into a voltage, which the ADCs can interpret. One of the legs of the CT is anchored to 2.5 volts (with the voltage dividers R12 & R13, and R15 & R16). The burden resistors are intended to provide a peak-to-peak maximum voltage of 5 volts. R33 and D4 & D5 (and R32, D6 & D7) form a clamp to protect the controller from excessive excursions.

== Relays ==

The relay outputs are fed from fairly standard open collector circuits (R2 & Q1; R1 & Q2). D1 and D2 protect the transistors from coil collapse voltages.

== Controller ==

The controller is fused for external crystal timing, and a 16 MHz crystal is chosen to be compatible with the Arduino IDE. The ISP programming pins (including /RESET) are connected to an ISP header. Those pins are not shared with other functions. The i2c bus is brought out to a 4 pin header for an LCD and the async serial pins are brought out to an FTDI connector. DTR on the FTDI connector is connected to /RESET through a capacitor so that DTR transitions can reset the CPU. If you load an Arduino style bootloader, then programming can be done with an FTDI cable instead of an ISP cable. Alternatively, since 5 volts is supplied to the FTDI cable, it can power external serially connected devices.

The inlet's AC power is connected to an off-board AC-to-DC converter module which outputs 12 volts. DC-DC converter DC2 converts this into 5 volts for the controller and the rest of the logo system.

= Images =

[http://www.kfu.com/~nsayer/evse/photo%2012.JPG]
The 0.9 board fully assembled.

= Resources =

  * [http://github.com/nsayer/hydra Software repository for the Hydra]
  * [http://code.google.com/p/arduino-pwm-frequency-library PWM library]
  * [http://github.com/lincomatic/LiquidTWI2 LiquidTWI2 library]
  * [http://oshpark.com/profiles/nsayer OSHPark store for Hydra boards]