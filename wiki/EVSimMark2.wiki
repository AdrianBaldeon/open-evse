#summary EV Simulator for testing EVSEs that includes pilot analysis

= Introduction =

In creating your own EVSE, it is often helpful to be able not only to send the pilot signal into the various states (including missing diode), but to analyze the frequency and duty cycle of the pilot being presented. Measuring frequency can be done by some higher-end VOMs, but duty cycle typically requires an oscilloscope.

In lieu of that, I've taken some of the circuitry from the Hydra and an ATTiny85 microcontroller and created a small(ish) extension to the EV Simulator which uses the controller to analyze the pilot and report its frequency, duty cycle and the resulting J1772 amperage allowance either via the 2 line LCD "backpack" from the OpenEVSE store (or the AdaFruit shield) or via asynchronous serial via an FTDI connector.

= Details =

You can download an Eagle board and schematic file from the project downloads. You have some no-stuff options if you like:

  * If you want to use the internal 8 MHz oscillator instead of a crystal, you can leave out the crystal and C5 and C6. If you do so, then you can expect the frequency readout to be off by as much as 10%. Also, you may have some difficulty with the async serial option, as the baud rate should, in principle, be within 5% in order to be reliable.
  * If you do not want to use the i2c LCD display option, you can leave out the i2c connector, the power jack, LM7805 and C1 and C2. You will be relying on the FTDI cable to power the circuit from your computer.
  * If you do not want to use FTDI, then you can leave that connector off.
  * If you have some alternate means to program your ATTiny chip, you can leave out the ISP connector. If you do so, then you can replace R9, R10 and R11 with jumpers.

For the sketch, you first need to configure the Arduino IDE to understand the ATTiny controllers. To do that, visit http://hlt.media.mit.edu/?p=1695 and download and install their ATTiny "master.zip" files. I also found that I needed to correct a bug in the AVR 'ld' command that came with Arduino. You need to fetch the patch at https://github.com/TCWORLD/ATTinyCore/tree/master/PCREL%20Patch%20for%20GCC and install it.

You need to fetch the TinyWireM library from https://github.com/adafruit/TinyWireM and install it. As of this writing, you need to also add a patched version of the LiquidTWI2 library. You can fetch that from https://github.com/nsayer/LiquidTWI2 and install it.

Next, fetch the sketch from https://github.com/nsayer/hydra/blob/master/EV_Sim.ino

Set the Arduino IDE up for either an ATTiny85 20 MHz (if using the crystal) or 8 MHz (if using the internal clock), burn the bootloader (this step doesn't actually upload a bootloader, but is required at least once to set the fuses), and upload the sketch.

Note that you cannot connect both the FTDI and i2c connectors at the same time. Both output mechanisms use the same controller pins. If the display is connected to the i2c connector, then it should be automatically detected and used at boot time. If you connect to the FTDI connector instead, you'll see a burst of line noise as the sketch starts, then you'll see the serial output take over after the i2c autodetection fails. Do not connect both at the same time. Also, although the sketch currently does not use the RD pin, you should connect it. The received data pin will serve to drag the SDA pin during the i2c autodetect phase and encourage it to fail.

To use, connect either a power source (6 volts minimum) and LCD or an FTDI connector to the board. Flip all four DIP switches off. Connect the ground and pilot pins of the pilot connector up to the EVSE under test. Your EVSE should show no vehicle connected. The display should show 0 Hz and 0% duty cycle.

Flip switch 4 (the one closest to the edge of the board) to "on". That should cause a transition to state "B". The EVSE should indicate a vehicle is connected. If it is prepared to supply energy, then you will see the display show 1000 Hz and a duty cycle and amp rating that's appropriate for the EVSE in question.

Flip switch 3 on to enter state "C". The EVSE will indicate that the vehicle has requested charging and should switch on the AC power. It goes without saying that at this point you must be extremely cautious as the two AC pins on the charge handle will be energized.

Flip switch 2 on to enter state "D". The EVSE will respond as appropriate for a ventilation request. Some EVSEs will error out, some will proceed without complaint. It depends.

Note that switches 4 through 2 act cumulatively. For example, you should not turn off switch 4 as you turn on switch 3. It is invalid to have a lower numbered switch (except switch 1) turned on without all of the higher numbered switches also on.

If you flip switch 1 on at any point, the EVSE should respond with a diode check failure and enter an error state.

=Theory of Operation=

The pilot from the EVSE is connected first to the DIP switches, which switch R2-4 in and out of place. The unswitched side of each resistor then goes to D1 and then to ground. Switch 1 on the DIP switch block shorts out the diode, simulating a "missing diode" for the diode check.

The sampling circuit also comes from the incoming pilot pin and is rectified by D2. This is necessary to prevent the negative portion of the pilot signal from arriving at IC1, which cannot tolerate negative voltages. Since the cathode side of D2 will float whenever the pilot is negative, R8 will pull the comparator input down to ground. To insure the comparator sees a definitive transition between the two states, a voltage divider provides approximately one volt to the inverting input. This means that the comparator output will be high when the pilot is higher than 1v. This should be sufficient to see the pilot oscillating even in state D. R5 is a pull-up for the LM393's open collector output.

The ATTiny85 controller is intended to be fused for an active /RESET pin (without this, high voltage programming would be necessary), and external crystal clocking. That occupies three of the I/O pins, leaving just 3 left (along with two power pins). Those 3 pins are first and foremost the SPI programming interface. During programming, the programmer must have priority over any other potential signals on those pins, so R9-R11 protect those pins from any stray signals that could be present.

When not in programming mode, two of the three available pins are slated as universal serial pins. They can be used to create a variety of different serial bus signals. We use the TInyWireM library to use them as an i2c bus. When the sketch is compiled to use async serial, we use SoftwareSerial to create a serial port on them instead.

The display will normally show the pilot frequency and duty cycle, along with a J1772 decoding of the amp rating for the given duty cycle. If the frequency is 0 (that is, no oscillations were detected at all), then the duty cycle will be replaced with either a "+" or "-", which indicate that the pilot is pinned either high or low (respectively).

=Links=

  * [http://oshpark.com/shared_projects/uhFbx38M OSHPark project for boards]
  * [http://hlt.media.mit.edu/?p=1695 Arduino support for ATTiny]
  * [https://github.com/TCWORLD/ATTinyCore/tree/master/PCREL%20Patch%20for%20GCC ATTiny Arduino patch]
  * [https://github.com/adafruit/TinyWireM TinyWireM]
  * [https://github.com/nsayer/LiquidTWI2 LiquidTWI2]
  * [https://github.com/nsayer/hydra/blob/master/EV_Sim.ino The EV Simulator sketch]